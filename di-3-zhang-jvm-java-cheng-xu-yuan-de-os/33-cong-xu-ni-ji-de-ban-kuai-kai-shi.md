## 3.1 Hotspot VM 板块划分
`Heap` 区主要包含 `Young` 和 `Old` 。其中前者大小大概是后者的 1/4~1/3 。但是这只是参考值。  
常见设置：使用 `Xms` 设置 `Heap` 的初始值， `Xmx` 设置 `Heap` 最大值。`-XX:MinHeapFreeRatio` 设置当 `GC` 后剩余空间的百分比小于这个值， `JVM` 堆内存变大。  
  
`Young` 空间被分为 2 个部分、3个板块，即“1 个 `Eden` 区 + 2 个 `Survivor` 区”。  
`Eden` 区中，使用 `new` 或 `newInstance()` 等方式创建的对象，默认都是先将对象的空间放到 `Eden` 区域，（除非这个对象太大了 `Eden` 区放不下，或者设定了一个对象阈值 `-XX:PretenureSizeThreshold` ，这样对象在分配的时候就会直接进入 `Old` 区）。  
2个 `Survivor` 区通常简称为 S0、S1,理论上这两个一样大，当然可以设置参数进行改变。  
  
在不断创建对象的过程中， `Eden` 区会满，满的时候就会开始做 `Young GC`（`Minor GC`），而 `Young` 空间的第一次 `GC` 就是找出 `Eden 区活着的对象`，将这些活着的对象向 `Eden` 区存放。  
假如第一次选择了 S0，它会逐步将活着的对象拷贝到 S0区，但是如果 S0 空间放满了，剩下的活着的对象就只能放在 `Old` 区了。接下来的动作是将 `Eden` 区清空，此时大家注意 S1 区是空的。  
第二次 `Eden` 区满的时候，就将 `Eden` 中活着的对象 + S0 活着的对象迁移到 S1 ，迁移方式也一样（如果 S1 放不下，对象就会放到 `Old` 区）。  
第三次、第四次依次轮着存放 S1 、 S0 。这样保证了 `Survivor` 其中有一个是空的。反反复复多次没有被淘汰的对象也会放入 `Old` 区。  
因此得出以下结论：  
1. 即使 `Young` 空间很大，但是活下来的对象是少数的，那么寻找或者的对象就会很快。
2. 由于活下来的对象不多，所以存放活下来的对象的空间并不需要太大，因此就产生了 `Survivor` 区。也因此它不会太大。
3. 如果程序跑得很慢，对象的存活周期就会变长，被方程垃圾的概率就会变小，当 `Survivor` 区存放不下时，就会进入 `Old` 区，所以有时候不仅仅是参数问题，程序跑的慢也和 `GC` 有点关系。
4. 内存大块，或者很多内存用静态区引用，就很可能一直存活，进入 `Old` 区的概率非常大。  
>进入 `Old` 区有什么坏处呢？  
`Old` 区与 `Young` 区不同， `Young` 区我们可以认为存活下来的对象很少，而 `Old` 区很多，认为它“足够老”，有可能是在 `Minor GC` 时，S0 或 S1 空间不够时对象才会去 `Old` 区。因为通常大部分对象是活着的， `JVM` 可以设置到 `10GB+` ，此时如果做一次 `Full GC` 找活着的对象，那么对性能影响很大。  
另外如果频繁地的发生 `Full GC` ，而这些活着的对象被注销的概率比较低，那么 `Full GC` 的时间就越长，就会有越多的请求得不到响应或响应很慢，它们所持有的内存就无法释放掉，就会有越多的对象进入 `Old` 区。  
另外 `Full GC` 通常会做压缩碎片操作。什么是碎片呢？ `Old` 区需要遍历内存，清除对象，由于有这样一个清除动作，所以就会导致内存中产生许多碎片，如果碎片很多，自然就会导致分配空间出现一些麻烦，因此需要整理碎片。  
另外， `Full GC` 是全局的不仅仅是 `Old` 区。
  
设置 `-XX:SurvivorRatio=8` 和 `-XX:InitialSurvivorRatio=8`。前者是 `Eden/某个Survivor` 的比值，即整个空间 S0 和 S1 各占 1/10，然后 `Eden` 区占 8/10 。后者是 `Young/S0` 的比值，即 S0 和 S0 占整个 `Young` 区的 1/8 ，  `Eden` 占 `Young` 区的 6/8 。
>一个对象正常经历多少次 `Minor GC` 后对象才会进入 `Old` 区呢？  
使用 `-XX:MaxTenuringThreshold=15` 设置，当一个对象被第一次 `GC` 后，计数器会在此对象头部相应位置标记1。  
当然有特殊的时候，例如 `Young` 区某个对象被 `Old` 区某个对象引用这种情况。

## 3.2 “对象存放位置”小总结
1. 实例化一个对象时，除非对象特别大或者达到参数限制，那么都会在 `Eden` 区存放这个对象。
2. 第一次发生 `Minor GC` 时，会在 S0 或 S1 中选择一个区域将 `Eden` 区活着的对象写进去，如果某个 S 区域放不下，则会放入 Old 区， 然后清空 `Eden` 区。
3. 发生第二次 `Minor GC` 时，就会将 `Eden` 区中活着的对象 + S0 区中活着的对象拷贝到 S1 空间，如果 S1 区放不下，则会进入 `Old` 区，最后将 `Eden` 区和 S0 区清空。
4. 第三次就将 `Eden` 区总活着的对象拷贝到 S0 ，再将 `Eden` 和 S1 区清空，一直循环。
5. 在业务中某些对象本来只有很短的生命周期，但是由于比较大，进入了 `Old` 区，导致在没有发生 `Full GC` 之前不会被释放掉，因此 `Survivor` 区域的大小在一定程度上决定了 `Old` 区的增长速度，也间接决定了 `Full GC` 的频率。  
6. 如果从 S 区到 `Old` 区中，发现 `Old` 区没有足够空间，则直接引发 `Full GC` 。
7. 大量