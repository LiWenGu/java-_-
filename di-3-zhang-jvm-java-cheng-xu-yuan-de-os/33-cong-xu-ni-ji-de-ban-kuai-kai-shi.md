## 3.1 Hotspot VM 板块划分
`Heap` 区主要包含 `Young` 和 `Old` 。其中前者大小大概是后者的 1/4~1/3 。但是这只是参考值。  
常见设置：使用 `Xms` 设置 `Heap` 的初始值， `Xmx` 设置 `Heap` 最大值。`-XX:MinHeapFreeRatio` 设置当 `GC` 后剩余空间的百分比小于这个值， `JVM` 堆内存变大。  
  
`Young` 空间被分为 2 个部分、3个板块，即“1 个 `Eden` 区 + 2 个 `Survivor` 区”。  
`Eden` 区中，使用 `new` 或 `newInstance()` 等方式创建的对象，默认都是先将对象的空间放到 `Eden` 区域，（除非这个对象太大了 `Eden` 区放不下，或者设定了一个对象阈值 `-XX:PretenureSizeThreshold` ，这样对象在分配的时候就会直接进入 `Old` 区）。  
2个 `Survivor` 区通常简称为 S0、S1,理论上这两个一样大，当然可以设置参数进行改变。  
  
在不断创建对象的过程中， `Eden` 区会满，满的时候就会开始做 `Young GC`（`Minor GC`），而 `Young` 空间的第一次 `GC` 就是找出 `Eden 区活着的对象`，将这些活着的对象向 `Eden` 区存放。  
假如第一次选择了 S0，它会逐步将活着的对象拷贝到 S0区，但是如果 S0 空间放满了，剩下的活着的对象就只能放在 `Old` 区了。接下来的动作是将 `Eden` 区清空，此时大家注意 S1 区是空的。  
第二次 `Eden` 区满的时候，就将 `Eden` 中活着的对象 + S0 活着的对象迁移到 S1 ，迁移方式也一样（如果 S1 放不下，对象就会放到 `Old` 区）。  
第三次、第四次依次轮着存放 S1 、 S0 。这样保证了 `Survivor` 其中有一个是空的。反反复复多次没有被淘汰的对象也会放入 `Old` 区。  
因此得出以下结论：  
1. 即使 `Young` 空间很大，但是活下来的对象是少数的，那么寻找或者的对象就会很快。
2. 由于活下来的对象不多，所以存放活下来的对象的空间并不需要太大，因此就产生了 `Survivor` 区。也因此它不会太大。
3. 如果程序跑得很慢，对象的存活周期就会变长，被方程垃圾的概率就会变小，当 `Survivor` 区存放不下时，就会进入 `Old` 区，所以有时候不仅仅是参数问题，程序跑的慢也和 `GC` 有点关系。
4. 内存大块，或者很多内存用静态区引用，就很可能一直存活，进入 `Old` 区的概率非常大。  
>进入 `Old` 区有什么坏处呢？  
`Old` 区与 `Young` 区不同， `Young` 区我们可以认为存活下来的对象很少，而 `Old` 区很多，认为它“足够老”，有可能是在 `Minor GC` 时，S0 或 S1 空间不够时对象才会去 `Old` 区。因为通常大部分对象是活着的， `JVM` 可以设置到 `10GB+` ，此时如果做一次 `Full GC` 找活着的对象，那么对性能影响很大。  
另外如果频繁地的发生 `Full GC` ，而这些活着的对象被注销的概率比较低，那么 `Full GC` 的时间就越长，就会有越多的请求得不到响应或响应很慢，它们所持有的内存就无法释放掉，就会有越多的对象进入 `Old` 区。  
另外 `Full GC` 通常会做压缩碎片操作。什么是碎片呢？ `Old` 区需要遍历内存，清除对象，由于有这样一个清除动作，所以就会导致内存中产生许多碎片，如果碎片很多，自然就会导致分配空间出现一些麻烦，因此需要整理碎片。  
另外， `Full GC` 是全局的不仅仅是 `Old` 区。
  
设置 `-XX:SurvivorRatio=8` 和 `-XX:InitialSurvivorRatio=8`。前者是 `Eden/某个Survivor` 的比值，即整个空间 S0 和 S1 各占 1/10，然后 `Eden` 区占 8/10 。后者是 `Young/S0` 的比值，即 S0 和 S0 占整个 `Young` 区的 1/8 ，  `Eden` 占 `Young` 区的 6/8 。
>一个对象正常经历多少次 `Minor GC` 后对象才会进入 `Old` 区呢？  
使用 `-XX:MaxTenuringThreshold=15` 设置，当一个对象被第一次 `GC` 后，计数器会在此对象头部相应位置标记1。  
当然有特殊的时候，例如 `Young` 区某个对象被 `Old` 区某个对象引用这种情况。

## 3.2 “对象存放位置”小总结
1. 实例化一个对象时，除非对象特别大或者达到参数限制，那么都会在 `Eden` 区存放这个对象。
2. 第一次发生 `Minor GC` 时，会在 S0 或 S1 中选择一个区域将 `Eden` 区活着的对象写进去，如果某个 S 区域放不下，则会放入 Old 区， 然后清空 `Eden` 区。
3. 发生第二次 `Minor GC` 时，就会将 `Eden` 区中活着的对象 + S0 区中活着的对象拷贝到 S1 空间，如果 S1 区放不下，则会进入 `Old` 区，最后将 `Eden` 区和 S0 区清空。
4. 第三次就将 `Eden` 区总活着的对象拷贝到 S0 ，再将 `Eden` 和 S1 区清空，一直循环。
5. 在业务中某些对象本来只有很短的生命周期，但是由于比较大，进入了 `Old` 区，导致在没有发生 `Full GC` 之前不会被释放掉，因此 `Survivor` 区域的大小在一定程度上决定了 `Old` 区的增长速度，也间接决定了 `Full GC` 的频率。  
6. 如果从 S 区到 `Old` 区中，发现 `Old` 区没有足够空间，则直接引发 `Full GC` 。
7. 大量使用 `intern()` 调用不同的 `String` 对象，会在 `Perm` 形成拷贝，并被引用指向，则 `Full GC` 不会清楚，最终导致 `OOM` 。
8. 如果栈被无限消耗，递归使用，导致出现 `StackOverflowError` 。

## 3.3 关于永久代
`Class` 加载，其实被加载到永久代（ `PermGen` ）。永久代不仅仅存放 `Class` 。当我们调用 `intern()` 方法时，它会在 `PermGen` 一块所谓的“常量池区域”中查找是否有相同值的常量（使用 `equals()方法进行匹配` ）。
>`static` 数据放在哪里？  
静态数据存储的位置其实是在方法内部，也就是 `Class` 所存在的位置内部，在 `Class` 初始化时，这块区域就被分配了（ `Class` 本身也是一个对象）。  
如果是静态引用，它的生命周期将是从所在类加载到所在类卸载。  
如果是普通基本类型，那么占用的是和这些类型等价宽度的空间大小。  
如果是引用，则存放引用的大小，（如果是 `final` 类型，则它引用的对象将于其“同寿”，如果不是，则直到这个静态引用的值发生改变，且这个对象不再有其它的引用指向它位置）。  
换句话说，一旦静态引用来引用对象，通常对象是长命的。  
  
作者认为，`PermGen` 设计初衷是认为这块区域应该不会被回收或几乎不回去参与回收，例如 `Class` 结构一旦加载就不会改变一样。  
  
但是随着 `Java` 功能增强，永久代的功能并不这么透明。例如，“字节码增强”就可以改变 `Class` 内部结构，是的永久代的空间可能受到程序的控制。还有常量池等，就使得这块区域不得不在某些时候去 `GC` 。就逐渐失去单独划分的必要性。  

## 3.4 此图保平安
![][1]

[1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/deeplearnjavawebtech/deeplearnjavawebtech-8-1-1.jpg