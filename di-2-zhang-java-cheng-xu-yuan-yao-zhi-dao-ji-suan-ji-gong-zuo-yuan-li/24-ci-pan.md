# 我很慢，但是我很便宜

---

## 4.1 `SSD` 硬盘

`SSD` 硬盘存在的灵感来自于“磁带”（磁带是最便宜、密度最大的顺序存储设备），也就是“机械刻录”和“机械读取”，它发展这么多年来，一直以：提高转速、增加盘片来提升单盘速度，通过尺寸大小、阵列、冗余等方法来提高容量和稳定性，即使是高端存储也离不开这些原理（只是做了更多的冗余、更多的缓存设备、更多的策略与算法来提高性能和保证数据不丢失）。但是由于磁盘本身的磁头原理所限制，磁盘本身的效率一直不高。

市面上的机械硬盘大多以 `SATA` 、 `SAS` 为主， `SATA` 盘十分便宜， `PC` 上用的很多都是这种盘（现在某些 `IT` 公司为了让开发者的机器跑得更好，原装的 `PC` 也不再用 `SATA` 盘了）一些测试服务器也可以使用它，因为这样会比较省钱。

`SATA` 盘的 `IOPS` 低的可能只有 60 左右。 `SAS` 盘相对 `SATA` 盘要贵一些，自然也会更快一些，现在很多数据库的线上服务器会使用这种硬盘，它们的 `IOPS` 通常能达到 120 左右。

直到最近几年，随着 `SSD` 硬盘的问世， `IOPS` 的概念逐渐变成了“笑话”，许多优化算法也瞬间被秒杀。 `SSD` 硬盘采用了很多内存的设计原理，而非机械硬盘的转盘思想，可以实现多通道读/写操作， `IOPS` 开始有了“飞一般的感觉”。 `SSD` 硬盘本身的访问性能可以说已经十分高了，不过由于接口大多还是 `SATA` ，在传统机型的配置上 `SSD` 硬盘的性能一直达不到它本身的极限，但也已经远远超越了机械硬盘几十倍甚至上百倍（对于 `SSD` 硬盘，已经有 `PCIE Express` 的标准正在制定）。（笔者现在使用的就是 `PCIE` 标准的硬盘，家用价格还能接受，但是性能让人着迷）

## 4.2 机械硬盘基本原理

存储空间大，在断电的时候不会丢失数据，所以存储在硬盘上的数据又叫持久化数据。

加载程序也需要从硬盘中读取，它是在进程启动时被加载的，但程序所占用的空间本身不会太多。在程序中做得最多的是对数据的读/写操作，机械硬盘与内存通信。机械硬盘效率低的原因在于 `IOPS` ，即本身的“读/写效率”。

首先，它有一个“摆头”，摆头在位于半切面的位置摆动，在盘片上进行“寻道”操作，找到数据所在的磁道后，通过磁盘本身的不断“转动”转到数据实际的起始位置，才开始真正读取数据，而读取数据之前的时间，都可以被认为是延迟时间。磁盘查找数据基本示意图如下：  
![][1-1]

而摆头能否快速找到磁道，一般情况下和尺寸有关系，而磁道内寻址和转速有关系，所以硬盘厂商一般都会提供这些参数。例如 15000 转/分的磁盘，磁盘旋转一圈的时间是：1000ms\*60s/15000 = 4ms 。一般来讲，厂商通常会按照“半转”的旋转时间作为“平均寻址延迟时间”，所以这种硬盘的寻址延迟时间大概是 2ms ，加上寻道时间 3~4ms ， 也就是 5~6ms 时间（内存是 ns 级）。

当硬盘找到数据后，前面提到加载 `4KB` 和加载 `1MB` 数据的时间差别并不大，所以往往许多小的 `I/O` 都是 `KB` 级别的，会不断地随机读/写硬盘，不断地寻道和寻址，那么自然在每次 `I/O` 时都会有这样的延迟。因此，在随机 `I/O` 操作较多的系统中， `IOPS` 成为其重要的量化标准。

除此之外，一些硬盘厂商在同一块硬盘上使用了“多个盘片”，这是用来干什么的呢？

摆头依然还是串行的，虽然在每个盘片上都有磁头，但是它只是为了提高读/写的效率。可以将数据分布写到多个盘片上，例如 3 个盘片，在写入数据 1、2、3 的时候，就可能将 2 这个数据写到不同的盘片上，读的时候会被重新组合起来，那么在磁头定位到数据后，读/写的效率可以提升数倍，但摆头定位磁道及磁道本身转动到数据位置的时间依然不会减少。

> 因此可以发现，这样的方式对于顺序读/写的操作可以加快速度，而对于随机读/写作用不大（因为大量的随机读/写将导致大量的 `I/O` 请求，而每次请求都会存在摆头定位磁道及磁盘旋转到指定位置的延迟）。

磁盘这么慢，能支持全世界的存储，靠的就是阵列、存储厂商提供的各类大型存储设备。阵列就是大家常说的“RAID”，它是一张卡，相当于一层硬盘的代理。有很多种 `RAID` 方式，现在做得最多的就是 `RAID5` 和 `RAID10` 。

`RAID5` 可以实现硬盘负载均衡（又见负载均衡！），并且可以在坏掉任意一块硬盘的情况下，将内容进行恢复，但是不能坏掉两块或更多的硬盘（如果有 3 块硬盘做 `RAID5` ，那么比一块硬盘的读/写性能理论上提升 1 倍，其中任意一块坏掉，都可以通过另外两块找回数据）。

`RAID10` 可以实现一半硬盘的负载均衡效率，每一块硬盘都有一块冗余的硬盘和它存储一样的数据（读操作访问其中任意一块都可以）。在这种情况下，只要不是相邻备份的两块硬盘“同时”坏掉，就不会丢失任何数据。

## 4.3 在 `Java` 程序中使用硬盘吗
通常程序和磁盘直接打交道的就是写日志较多，通过网络 `I/O` 让数据库访问磁盘也间接地算是一种硬盘操作。  
  
当然，数据库一般由一个 `DBA` 来关注它的实现，而开发者需要懂得你写的 `SQL` 大概对 `I/O` 有多大影响，因为系统的瓶颈会在这里。将这个思路再放大一些，在设计上或许采用相对批量、本地化操作来提升整体效率，在第 6 章讲会介绍。  
  
而对于硬盘本身，拿日志来说，许多日志写工具，会将日志替换为 `Buffer` 的 `append` 方法，它将日志写入一个缓存区中，由专门的程序来实现日志写操作，或者写的时候发现缓存区已满，则本次写入磁盘。这样一来，一次写入多条数据，每次写入量就开始变大，也就是将随机 `I/O` 逐渐变成顺序 `I/O` 操作（将多次硬盘寻道、寻址“尽量”变成一次）。
>所谓“尽量”当然就是“不确保”，一个原因是磁盘上可能有磁盘碎片会导致重新寻址，随意碎片清理也很重要。  
另外是 `Buffer` 多大的问题，过大的 `Buffer` 一次写入磁盘时也并非是一次性写入的，而且过大的 `Buffer` 会占用 `JVM` 的内存空间长期占有或过大就会占用 `Old` 区域的空间，使得它更容易做 `FULL GC` 。因此，要中庸。
  


[1-1]: http://leran2deeplearnjavawebtech.oss-cn-beijing.aliyuncs.com/learn/javaspecialtropps/1-1.png "磁道"
