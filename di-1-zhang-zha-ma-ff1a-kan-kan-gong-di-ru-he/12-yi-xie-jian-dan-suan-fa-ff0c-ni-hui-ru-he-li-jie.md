# 如果你对算法很熟悉，请跳过此节。

---

想要从一堆数据中找出一个 max 、 min 。你的想法是什么？假如一个学校有几千人，你要找一个人，下面几种方法，你选哪一种？
1. 几千人逐个去问。
2. 我知道要找人的年龄，然后在年级中每个班级按照方法1继续做同样的事情。
3. 我知道具体的班级，然后在班级里面按照方法1一样逐个问。
4. 我知道姓名，通过姓名得到有几个班级同名的人，这几个人中我逐个问。
5. 我知道班级和姓名，也许就1个或2个学生同名，然后逐个问。
6. 我知道“学号”，直接找到人。  
  
第一种方法肯定是最傻的方法。但是我们的程序往往就是这样写的，一个长长的for循环加匹配。后面几种方法都是知道某些前提内容后，然后通过不同的**索引**手段找到了人。

## 2.1 从一堆数据中找出 max 和 min
一堆数据中没有数据分组的概念，我们只需要找出最大值和最小值就可以了，排序的代价太大了。可以先给一个临时变量赋值为 `Integer.MIN_VALUE` 或数组中的第1个元素值，然后循环数组的每个下标，只要比当前这个值大，就给它赋予最新的值。  
  
进步一来看这个问题，就像100个人进行羽毛球比赛，最终需要挑选出水平最高的哪一个人，最少会比赛99场。那有没有其他的方法呢？或许可以让凉凉之间进行较量，高手再两两之间继续较量，最后决出胜负，但是比赛的次数仍然是 N-1 次（例如8个人，首先4场胜出4人，然后2场胜出2人，最后一场加起来就是7场）。这种方式有一个重要的特种——在两两比赛的时候，只要有足够多的场地，就可以一起比赛，**那么总体时间就节约下来了，在计算机中就是“多线程”技术**。  
  
前者的设计方法由于简单，无法实现这种并行，但是前者只要在 for 循环里面需要处理的内容足够简单，效率依然很高。  
  
将这个问题再做一点“发散性”扩展：在一堆杂乱无章的数据中，需要求出某个数据从小到小的“排名”情况，如果排序导致时间开销过多，则可以定时做完全排序，外部的请求直接从排序结果中获取即可，如果找不到请求的数据结果，则只需要找出比这个数据大的数据个数自然就知道排名了。但是需要忍受数据上的延迟。

## 2.2 从100万数字中找出最大的10个数字
可以初始化10排好序个数字，循环大数组的每个元素，如果当前数字大于这10个数字的最小值，就剔除最小值，将当前数字写进入，即使在最坏的情况下，每个数字都要插入到10个数字中剔除最小的，也最多是10*100万的运算量。

## 2.3 关于排序，实际场景很重要
实际的场景很重要，假如有“杂乱无章”的数据（200万个数据），两层 for 循环得到一个 n^2 的复杂度。我们开始分析业务场景，如果我们发现这些数据中有95%以上是相对均匀分布在1~200万之间的，而且重复数据极少，那么在这种场景下会如何排序？  
  
先分堆再排序。由于数据较为均匀，所以将它们分成2002份甚至更多，例如[1-1000]、[1001-2000]...，每个区间的数据范围是一个小堆，而且小堆之间的数据是有序的，“<1”和“>200万”的数据各自再分一个小堆，2002个堆之间的数据是完全有序的，因此只要它们各自内部有序，就是全局有序。这个过程需要扫描100万数据一次，然后在2002个堆中找到自己的位置，由于它本身有序，所以采用二分查找是可以快速找到位置的（每次匹配范围会缩小1倍，在2002个范围中寻找，每个数字最坏匹配11次（因为2的11次方是2048），总体上11*100万=1100万）。  
  
此时平均每个堆大概是1000条数据，那么每个堆自己排序的最坏时间复杂度将是1000\*1000=100万（两层 for 循环），有2002个堆，因此是100万*2002=20.02亿，加上分堆的开销1100万，一共是20.13亿，虽然比较高，但是比4万亿降低了500倍。  
  
类比生活的场景，就是先排好顺序的班级，每个班级内部排序，采用的是分块排序，只是唯一的区别是，分块排序完成后就不需要再进行板块之间的排序了。

## 2.4 数据库是怎么找到数据的
上一节的例子，将一些数据划分为板块，但是由于数据太多，就会造成板块太多或板块内部的数据太多，此时就会有管理板块的板块。数据库通常承载的数据量都上亿（单表大小），甚至十亿以上，它是怎么做的呢？  
  
其实数据库也离不开这些原理，大多数数据库的索引都会用换汤不换药的“B+树”（当然也有使用Hash来做索引的），此思想源自对平衡二叉树的一种扩展，而同时也来自基本算法——二分查找算法。  
  
例如， SQL 操作表与表之间的 join 的时候，如果是已经排序好的两个列表， join 就无须完全的两层 for 循环来操作，那是N*N的时间复杂度。  
  
假如 A 表与 B 表，到 B 表中查找 A 表的一个数据100，它从 B 表中最小的数据开始找，找到了许多小于100的数据，不过都排除在外，不论是否找到100这个数据，当去 B 表查找 A 表的下一个数据101的时候，就不会再从最小值开始找了，而是从100开始，因为数据库知道双方是有序的。随着这个规律的推移，扫描的数据范围会越来越少，而不是像两层 for 循环那样，每一个外部的 for 循环都需要在内存中的第1个下标开始扫描（join 表的个数请不要超过3个表，来自阿里开发手册）。

## 2.5 Hash 算法的形象概念
其实 Hash 有很多种，有简单 Hash ，还有一致性 Hash 等，这里我们就谈谈简单 Hash 算法。关于 Hash 算法，经常会在教材中看到： Hash 桶，快速定位，先计算再定位，并且号称复杂度为O(1)。  
  
在Java语言里 hash 算法通常是按照 hashCode 来分布的，前面提到过，在不同的场景下这个 hashCode 会计算出不同的值——可用对象头部的一个标识符，可用某些对象的属性通过一定的计算得到，同一个 hashCode 肯定是同一个分组上，这个分组也就是专业说法上的“桶”，“桶”内部的数据通常是无序的，通常内部用一个链表存放（有的人会问链表不是有序的吗？其实这里所谓的无序是指链表上存放的数据并没有要求外部写入的数据以先进先出或后进先出的顺序存放，外部程序也不能依赖于遍历的顺序）。  
  
在查找数据时，首先根据 hashCode 找到桶，然后在这个桶内部需要逐个使用 `equals()` 方法来对比内部的值，而在极度冲突的情况下，许多数据将被放在同一个桶中（通常叫做“热点”），导致一个桶的数据链表会非常长，这样一来，分布在该桶的查找、遍历等操作都会变得很慢。因此，千万不要因为 Hash 算法的复杂度是O(1)就认为它天下无敌了，其实这只是一个想对量级别的说法，实际场景中的开销我们要用数字来说话。  
  
反过来说，如果要使用 Hash 来做大量数据的查找，那么需要设计合适多的 Hash 桶。另外，在设计 hashCode 、 hashCode与桶的下标转换的时候要有足够的离散能力，否则会做“赔了夫人又折兵”的事情。