引子代码如下：

```java
private static void testStr() {
    String a = "a" + "b" + 1;
    String b = "ab1";
    System.out.println(a == b);
}
```
结果为true，为什么呢？要理解这个问题，你需要了解：  
1. 关于“==”是做什么的？  
2. equals呢？  
3. a和b在内存中是什么样的？（指向同一个内存地址）
4. 编译时优化方案。

---

## 1.1 关于“==”

在Java语言中，当“==”匹配的时候，对比的是两个内存单元的内容是否一样。

如果是原始类型 byte、boolean、short、char、int、long、float、double ，则直接比较值。

如果是引用（Reference），比较的就是引用的值，“引用的值”可以被认为是对象的逻辑地址。即比较两个对象的地址值是否一样。换一句话说，如果两个引用所保存的对象是同一个对象，则返回true。（如果引用都指向的是null，即也为true）。

## 1.2 关于“equals()”

在Object类中的源码如下：

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

因此，如果没有重写过 `equals()` 方法，那么默认的 `equals()` 操作就是对比对象的地址。String就自己重写了 `equals()` 方法。自己定义的类重写这个方法，主要用于两个对象根据业务的关键属性值来对比，确定它们是否是“一致性的或相似的”，返回true|false即可。

那么 `equals()` 重写后，一般会重写 `hashCode()` 方法吗？

1. Java 中的 hashCode 是什么？  
 `hashCode()` 方法提供了对象的 hashCode 值，它与 `equals()` 一样在 Object 类中提供，不过它是一个 native 方法，它的返回值默认与 `System.identityHashCode(object)` 一致。在通常情况下，这个值是对象头部的一部分二进制位组成的数字，这个数字具有一定的标识对象的意义，但绝不等价于地址。

2. hashCode 的作用是什么？  
它为了产生一个可以标识对象的数字，不论如何复杂的一个对象都可以用一个数字来标识。为什么需要用一个数字来标识对象呢？因为想将对象用在算法中，如果不这样，许多算法还得自己去组装数字，因为算法的基础是建立在数字基础之上。那么对象如何用在算法中呢？例如，在 `HashMap` 、 `HashSet` 等类似的集合类中，如果用某个对象本身作为 Key，也就是要基于这个对象实现 Hash的写入和查找，那么对象本身如何能实现这个呢？就是基于这样一个数字来完成的，只有数字才能真正完成计算和对比操作。

3. hashCode 方便算法， `equals()` 方便业务， “==”方便对象值的内存地址的比较。
hashCode 只能说是标识对象，因此在Hash算法中可以将对象相对离散开，这样就可以在查找数据的时候根据这个 key ，快速地缩小数据的范围。但不能说 hashCode 值一定是唯一的，所以在 Hash 算法中定位到具体的链表后，需要进一步循环链表，然后通过 `equals()` 来对比 Key 的值是否是一样的。这时 `hashCode()` 与 `equals()` 似乎就成为“天生一对”。换句话说，一个是为了算法快速定位数据而存在的，一个是为了对比真实值而存在的。 `hashCode()` 的重写，返回值最好是能够将对象相对离散的数据。如果发生一个极端的情况，即 `hashCode()` 始终返回一个值，那么它们将存在于 `HashMap`的同一个链表中，将会比链表查询本身还要慢（next到最后一个链表）。

